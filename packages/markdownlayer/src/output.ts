import { copyFile, writeFile } from 'node:fs/promises';
import { join, relative } from 'node:path';

import { logger } from './logger';
import type { ResolvedConfig } from './types';
import { generateTypeName, getDataVariableName } from './utils';

const emitted: Record<string, string> = {};

// NOTE Type assert statements for `.json` files are necessary from Node v16.14 onwards
const nodeVersionMajor = parseInt(process.versions.node.split('.')[0]);
const nodeVersionMinor = parseInt(process.versions.node.split('.')[1]);
const needsJsonAssertStatement = nodeVersionMajor > 16 || (nodeVersionMajor === 16 && nodeVersionMinor >= 14);
export const assertStatement = needsJsonAssertStatement ? ` assert { type: 'json' }` : '';
export const autogeneratedNote = `// NOTE This file is auto-generated on build.`;

export async function outputEntryFiles({
  definitions,
  mode,
  configPath,
  output: { generated: destination },
}: Pick<ResolvedConfig, 'definitions' | 'mode' | 'configPath' | 'output'>) {
  const types = Object.keys(definitions);

  // generate entry according to `config.collections`
  const configModPath = relative(destination, configPath)
    .replace(/\\/g, '/') // replace windows path separator
    .replace(/\.[jt]s$/i, ''); // remove extension (mjs, cjs, mts, and cts are excluded)

  // write the index.d.ts file
  let lines: string[] = [
    autogeneratedNote,
    '',
    `import { z } from 'zod';`,
    `import config from '${configModPath}'`,
    '',
    'type Definitions = typeof config.definitions;',
    'type ReturnTypeOrOriginal<T> = T extends (...args: any[]) => infer R ? R : T;',
    `type InferSchema<D extends keyof Definitions> = z.infer<ReturnTypeOrOriginal<Definitions[D]['schema']>>;`,
    '',
    ...types.map((type) => `export type ${generateTypeName(type)} = InferSchema<'${type}'>`),
    '',
    ...types.map((type) => `export declare const ${getDataVariableName(type)}: ${generateTypeName(type)}[];`),
    '',
  ];
  let filePath = join(destination, 'index.d.ts');
  await writeFile(filePath, lines.join('\n'), { encoding: 'utf8' });

  // write the index.mjs file
  lines = [
    autogeneratedNote,
    '',
    '// NOTE During development imports are done from `.mjs` files to improve HMR speeds.',
    '// During (production) builds imports are done from `.json` files to improve build performance.',
    '',
    ...types.map((type) => {
      const dataVariableName = getDataVariableName(type);
      return mode == 'development'
        ? `import { default as ${dataVariableName} } from './${type}/index.mjs';`
        : `import { default as ${dataVariableName} } from './${type}/index.json'${assertStatement};`;
    }),
    '',
    'export {',
    `  ${types.map((type) => getDataVariableName(type)).join(',\n  ')},`,
    '};',
    '',
  ];
  filePath = join(destination, 'index.mjs');
  await writeFile(filePath, lines.join('\n'), { encoding: 'utf8' });
}

/**
 * Output all collected assets
 * @param options - output options
 */
export async function outputAssets({
  assets,
  output: { assets: destination },
}: {
  /** All collected assets */
  assets: Record<string, string>;
} & Pick<ResolvedConfig, 'output'>) {
  let count = 0;
  await Promise.all(
    Object.entries(assets).map(async ([name, from]) => {
      if (emitted[name] === from) {
        logger.debug(`skipped copy '${name}' with same content`);
        return;
      }
      await copyFile(from, join(destination, name));
      // logger.debug(`copied '${name}' from '${from}'`)
      emitted[name] = from;
      count++;
    }),
  );
  logger.debug(`output ${count} assets`);
}
